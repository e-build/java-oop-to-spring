<u>***목차***</u>
- [리팩토링](#리팩토링)
  + [@Inject 개선](#@Inject-개선)

# 리팩토링
### @Inject 개선
1. 인스턴스 생성과 주입 작업은 `BeanFactory`가 담당
2. 빈 설정 메타 정보를 별도의 클래스로 추상화하여 관리 => `BeanDefinition`
3. `BeanDefinition` 저장소 역할을 수행하는 인터페이스 분리 후 BeanFactory에 기능 부여 `BeanDefinitionRegistry`
4. `BeanScanner` => `ClasspathBeanDefinitionScanner`
5. `BeanFactory`와 `ClasspathBeanDefinitionScanner` 의존관계를 연결 후 초기화 객체 필요 => `ApplicationContext`

### 인사이트
아시다시피 객체지향 설계의 핵심은 객체의 역할과 책임에 대해 계속 고민하면서 한가지 역할과 책임을 가지도록 지속적으로 개선해나가는 것이다. 애플리케이션 구축을 시작하는 단계에서
객체의 역할과 책임을 명확히 설계하는 것은 불가능할 뿐더러, 비즈니스의 변화에 대한 예측은 더욱 어렵고, 당장 필요로 하지 않는 기능에 대한 확장성을 확보하기 위해 추측성으로 개발을 하는 것은
소스코드의 복잡도를 높일 것이다. 따라서 초반 설계를 철저히 하는 것도 중요하지만 그보다 애플리케이션은 언제든지 변경될 수 있다는 가정하에 변경이 발생했을 때 빠르게 대처할 수 있는 리팩토링 역량을 쌓는 것이 더 중요하다.

'자바 웹 프로그래밍 Next Step' 서적에서 저자 박재성님이 스프링 프레임워크를 학습하면서 느낀 경험을 공유한다.
```text
BeanFactory의 initialize() 메서드를 보면 빈 전체에 대한 인스턴스 생성과 DI를 진행하고 있는데 이 때 사용하는 메서드가 getBean()이다.
getBean()은 빈 인스턴스 생성과 DI작업을 하고 있다. 무엇보다 initialize() 메서드 내에서 getBean()의 반환값은 사용하고 있지도 않다.
즉 메서드가 담당하는 역할과 메서드의 이름이 맞지 않는 것이다. 객체지향을 학습하고 있는 누구나라면 'getBean()메서드를 분리하여 역할에 맞는 이름을 부여하는게 좋지 않을까' 
하는 생각이 자연스럽게 떠오른다.
...  
그런데 스프링 프레임워크 소스코드를 분석하다 BeanFactory의 똑같은 부분에서 getBean()메서드로 빈 인스턴스 생성과 DI처리를 하는 것을 보고 신랄하게 비판했던 기억이 난다.
getBean()을 사용하지 말고 createBean(), getBean()으로 나눈후 초기화 과정에서 createBean()을 사용하는 것이 더 낫지 않을까? 뭔가 의도가 있겠지만, 도저히 이해가 되지 않았다.
...
그런데 이 책을 쓰면서 BeanFactory를 직업 구현하다보니 초기화 과정에서 getBean()을 사용한 의도를 알게 되었다. getBean()은 빈 저장소에 빈이 존재하면 반환하고, 
그렇지 않을 경우 빈 인스턴스를 생성, DI를 한 후 저장소에 저장, 반환하는 작업을 담당한다. 그런데 이 과정을 분리할 경우 복잡도만 높아지고 초기화 과정에서 저장소에 빈이 존재하는 지를
매번 확인해야 하기 때문에 그리 좋은 선택이 아니었다.
그렇다고 스터디에 스프링 프레임워크 코드를 비한판 내 행동을 부끄러워하지 않는다. 비판을 했기 때문에 getBean() 메서드의 의도를 파악하기 위해 더 노력할 수 있었다.
오히려 코드를 비판적으로 보면서 나라면 어떻게 구현할 것인지에 대해 생각하는 것이 자신의 역량을 더 키울수 있다. 상대방이 구현한 코드를 무조건적으로 받아들이지 말고 
비판적인 시각으로 바라볼 때 자신만의 색깔을 만들 수 있고 역량을 키울 수 있다.
```