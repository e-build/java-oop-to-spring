<i><u>***목차***</i></u>
- [한계](#한계)
- [리팩토링](#리팩토링)
    + [설계](#설계)
    + [규칙](#규칙)

먼저 no-framework-web-not-refactoring 브런치가 가지는 한계점에 대해 고민해보고, 보다 객체지향적인 설계가 되기 위한 과정에서
어떤 객체지향 설계 원칙들과 요소들이 적용되었는 지 정리해 볼 것이다. 추가적으로 리팩토링 실시에 있어서 어떤 원칙들을 토대로 할 것이지도 함께 본다.
 
# 한계
1. `RequestHandler`가 가지는 복합적인 책임
   - HTTP 요청과 응답을 모두 run() 메서드에서 처리하고 있다.
   - 요청 URL과 HTTP 메서드에 따라 어떤 비즈니스 로직으로 연결시킬 것인지 매핑하는 작업을 처리하고 있다. 
   - 하나의 메서드의 길이가 길어지는 것은 해당 메서드가 그만큼 많은 역할을 담당하고 있을 확률이 높다는 것이다.
2. 비즈니스 변화에 따라 기존의 코드들이 수정되어야 하는 문제가 존재한다.
   - 요청에 따른 로직이 추가될 때 마다 `RequestHandler`의 run() 메서드에 `else if` 문을 추가하여 코드를 작성해야 하는 구조이다.
   - 기존의 코드를 변경하지 않으면서 기능을 확장할 수 있도록 추가되는 비즈니스 로직을 처리할 필요가 있을 것 같다.
3. 상수들이 문자열로 사용되고 있다. 
   - HTTP 통신에서 사용되는 약속된 값들이 있다. HTTP 요청과 응답에서 사용되는 헤더의 이름이나 값 혹은 Status Code 들이 대표적인 예시이다.
   - 이러한 상수 값들은 코드상에서 중복되어 사용되지 않도록 자바에서 어떻게 처리할 수 있는 지 고민할 필요가 있다.

# 리팩토링
### 설계
1. `RequestHandler`가 가지는 복합적인 책임 => ***<i><u>클래스 분리</i></u>*** 
   - [단일 책임 원칙(SRP)](https://github.com/e-build/java-oop-to-spring/blob/main/concept/oop-5-principle.md#srpsingle-responsibility-principle)
     에 따라 클래스가 하나의 책임만을 수행하도록 하기 위해서 다음과 같이 클래스들을 분리해 줄 것이다.
       - `InputStream`타입의 인스턴스를 전달받아서 HTTP 요청을 처리하는 `HttpRequest` 클래스 생성
       - `OutputStream`타입의 인스턴스를 전달받아서 HTTP 응답을 처리하는 `HttpResponse` 클래스 생성
       - `RequestHandler` 클래스가 HTTP 요청에 따라 적절한 비즈니스 로직을 처리하도록 위임하는 역할만 하도록 수정
  > 단일 책임 원칙에 따라 클래스들을 옳게 분리하기 위해서는 기존 `RequestHandler`클래스가 어떤 역할과 책임들을 수행했는 지 정의할 필요가 있다.
    단순히 너무 많은 기능을 하는 것 같아 보이는 클래스를 여러 개의 클래스로 나눈다는 생각으로 작업하면, 오히려 적절히 책임이 분배되지 않은 클래스들 간에 
    의존도를 높이는 방향으로 설계될 수도 있고, 이러한 설계는 충분히 재사용이나 수정, 유지보수가 용이한 설계가 아니다.
    따라서 `RequestHandler`를 분리한다는 것은 새로 생성되는 클래스들을 어떻게 [추상화](#)할 것 인지에 대한 고민과 맞물려 있고, 
    분리된 책임에 알맞게 클래스가 추상화될 수 있도록 고민할 필요할 있다는 것이다.
2. 비즈니스 변화에 따라 기존의 코드들이 수정되어야 하는 문제 => ***<i><u>인터페이스를 활용한 확장성 부여</i></u>*** 
   - [개방 폐쇄 원칙(OCP)](https://github.com/e-build/java-oop-to-spring/blob/main/concept/oop-5-principle.md#ocpopen-closed-principle) 
     에 따라 다음과 같이 설계를 변경할 것 이다.
     - `else if`문에서 HTTP 요청따라 분기하여 응답을 처리하는 것이 아니라, `Controller`인터페이스 구현하는 클래스에서 구체적인 비즈니스 로직을 처리하도록 하여 
       새로운 HTTP 요청처리가 필요할 때 `Controller` 인터페이스를 구현하는 클래스를 생성하여 기존 코드를 수정하지 않도록 변경할 것 이다. 
     - `Controller` 인터페이스를 통해 HTTP 요청을 처리할 수 있는 기능을 부여받는 클래스들을 생성한다고 생각할 수 있다. [(is able to)](https://github.com/e-build/java-oop-to-spring/blob/main/concept/oop-on-java.md#%EC%83%81%EC%86%8D%EA%B3%BC-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4)
3. 상수처리 => ***<i><u>자바 Enum 활용</i></u>***

### 규칙
프로그래밍 분야에서 <i>***리팩토링***</i>이라고 하는 것은 상당히 넓은 의미로 사용되는 만큼 때로는 그 의미가 와닿지 않게 느껴질 때도 많다. 흔히 다음과 같은 문구들인데,
```text
* 소프트웨어를 보다 쉽게 이해할 수 있고, 적은 비용으로 수정할 수 있도록 겉으로 보이는 동작의 변화 없이 내부 구조를 변경하는것.
* 일련의 리팩토링을 적용하여 겉으로 보이는 동작의 변화 없이 소프트웨어의 구조를 바꾸다.
* 패턴은 우리가 있고 싶은 곳이고, 리팩토링은 그곳에 이르는 방법이다.
* 긴 함수, 긴 클래스, 긴 매개변수 목록 제거
* 중복되는 코드 제거
```
실제로 설계를 변경하고 코드를 작성하는 입장에서 어떻게 해야할 지 상당히 막연해진다.
따라서 우리는 보다 방법론적인 차원에서 접근해보자. 리팩토링을 수행할 때 정량적인 규칙을 정해놓고 실시하는 것은 상당히 도움이 되는 데
이번 `no-framework-web-no-refactoring` 브런치를 리팩토링하면서 적용해볼 규칙들은 다음과 같다.
- 자바 코드 컨벤션을 지킨다
- indent depth를 2까지만 허용한다.
  (인덴트를 줄이려면 메서드를 계속 작은 단위로 분리할 수 밖에 없다.)
- 메서드가 한 가지 일만 하도록 최대한 작게 만든다.
- 메서드의 길이가 15라인을 넘어가지 않도록 한다.
- else 예약어를 사용하지 않는다.
    - if 조건절에서 값을 return하는 방식으로 구현하면 else를 사용하지 않아도 된다.
    - switch-case도 사용하지 않는다.
- Java API를 적극 활용한다. (메서드를 구현하기 전에 Java API에서 제공하는 기능인지 검색한다)
- 메서드의 인자수를 3개까지만 허용한다.
- 상태 데이터를 가지는 객체에서 데이터를 꺼내려하지 말고 객체에 메시지를 보내 검증한다. 