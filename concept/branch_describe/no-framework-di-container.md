<u>***목차***</u>
- [DI](#DI)
  + [DI 적용에 따른 불편함](#DI-적용에-따른-불편함)
- [요구사항](#요구사항)
- [DI 프레임워크를 구현하면서의 깨달음](#DI-프레임워크를-구현하면서의-깨달음)
  + [싱글턴 패턴의 한계](#싱글턴-패턴의-한계)
  + [테스트를 위한 Mock 객체 생성에 대한 지나친 비용](#테스트를-위한-Mock-객체-생성에-대한-지나친-비용)
  + [DI보다-우선하는-객체지향-개발](#DI보다-우선하는-객체지향-개발)
  
# DI
DI 프레임워크를 구현하고, MVC 프레임워크에 적용해야 하는 이유나 그 중요성에 대해서는 [여기]()에서 설명하고 있다.
이번 실습에서는 DI 프레임워크 설계와 구현 시 발생하는 이슈에 대해 더 집중해서 다룰 것이다.

### DI 적용에 따른 불편함
- 싱글턴 패턴을 적용함에 따라 망가지는 객체지향 설계

# 요구사항
1. 애플리케이션을 계층형으로 나누어 레이어별로 필요한 로직을 작성할 수 있도록 `@Controller`, `@Service`, `@Repository`
   애노테이션을 선언하여 로직을 구분한다.
   - 이전 실습에서 생성한 `@Controller` 뿐만 아니라 기능별 로직을 구분하여 구현하는 `@Service` 애노테이션과 
     DAO 역할을 수행하는 `@Repository` 애노테이션을 생성한다.
   - 세 애노테이션 모두 클래스 수준에서 사용된다.
   - `com.framework.core.new_mvc.annotation` 패키지 참고 
2. 의존관계 주입의 대상이 되는 생성자를 지정할 `@Inject` 애노테이션 추가
   - 단 이번 실습에서는 `@Inject` 어노테이션이 지정된 생성자는 클래스당 하나로만 제한한다. 
   - `com.framework.core.di.annotation` 패키지 참고
3. DI 컨테이너 역할을 수행할 BeanFactory 클래스를 생성한다.
   - 재귀함수 사용
     - 꼬리에 꼬리를 물고 빈(Bean)간의 의존관계가 발생할 수 있다. 다른 빈과 의존관계를 가지지 않는 빈을 찾아 
       인스턴스를 생성할 떄 까지 재귀를 실행하는 방식으록 구현할 수 있다.
     - `BeanFactory`의 `instantiateClass()`, `instantiateConstructor()` 참고
    ```java
    public class BeanFactory {
        Map<Class<?>, Object> beans;
        
        private Object instantiateClass(Class<?> clazz) {
            [...]
            return null;
        }
    
        private Object instantiateConstructor(Constructor<?> constructor) {
            return null;
            [...]   
        }
    }
    ```
4. DI 프레임워크를 MVC 프레임워크와 통합
   - `ControllerScanner`가 `@Service`, `@Repository` 에 대한 지원이 가능하도록 역할 변경 및 클래스명 변경(`BeanScanner`)
   - `AnnotationHandlerMapping`이 `BeanFactory`와 `BeanScanner`를 활용해 동작하도록 변경
5. `BeanFactoryTest`클래스의 테스트 코드 통과

# DI 프레임워크를 구현하면서의 깨달음
### 싱글턴 패턴의 한계
애플리케이션에 해당 인스턴스가 하나만 존재할 때 사용할 수 있는 디자인패턴이다. 상대적으로 이해하기 쉽고 구현도 쉬워서 많은 곳에서 
사용되지만 DI 프레임워크를 구현할 땐 그에 따른 여러 단점도 존재한다.
첫번째로 싱글톤 패턴으로 구현된 클래스와 의존관계 가지는 경우 해당 클래스와 강한 의존관계를 갖기 때문에 테스트하기 어렵다.
두번째로 생성자를 `private`으로 구현하기 때문에 상속할 수 없다는 단점이 존재한다.
또한 싱글톤 패턴 기반으로 개발하는 경우 객체지향 설계원칙에 따라 개발하는 것에 한계가 발생한다.

이 같은 한계점들 때문에 싱글톤 패턴을 사용하지 않으면서 인스턴스를 하나만 유지할 수 있는 다른 해결책으로써,
애플리케이션이 초기화되는 과정에서 인스턴스를 생성한 후 재사용하도록 설계하는 방법을 사용한다.
싱글톤 패턴을 사용하지 않으면서 인스턴스 하나를 사용하도록 하려면 컨트롤러에서 시작해 꼬리에 꼬리를 물고 DI하는 구조로 구현해야 한다,
의존관계의 깊이가 깊어지면 객체 간의 의존관계를 연결하는 작업이 쉽지 않을 것이라 예상할 수 있다.

### 테스트를 위한 Mock 객체 생성에 대한 지나친 비용
의존관계에 있는 객체가 존재하지 않더라고 테스트가 가능하도록 하기 위해 Mock객체가 필요한데, Mock 클래스를 직접 구현해야 하는 비용은 개발자에게
큰 부담이 될 수 있다. 그렇지 않아도 테스트 코드 작성에 어려움을 느끼는데 Mock클래스까지 구현해야 한다면 더 큰 부담이 될 수 있고, 이는 결국
테스트를 하지 않게 되는 결과에 도달한다. 

이 같은 단점을 보완하기 위해 자바 진영에서 많이 사용하느 테스트 프레임워크로 Mockito가 있다. 
Mockito는 @Mock 애노테이션으로 설정한 클래스의 메서드를 호출했을 때 반환값을 지정할 수 있다.
또한 @Mock으로 설정한 클래스의 메서드가 호출되는 지의 여부를 검증하는 작업 또한 가능하다.

```java
import org.springframework.test.context.TestExecutionListeners;

@Runwith(MockitoJUnitRunner.class)
public class ToyServiceTest {

    private ToyService toyService;

    @Mock
    private ToyDao toyDao;


    @Before
    void setUp() {
        toyService = new ToyService(toyDao);
    }

    @Test(expected = CannotDeleteException.class)
    void deleteToy_없는질문(){
        when(toyDao.findById(1L)).thenReturn(null);
        toyService.deleteToy(1L);
    }
}

```
따라서 다른 클래스와 의존관계를 가지는 클래스를 테스트하는 경우 Mockito와 같은 Mock 프레임워크를 사용할 것을 추천한다. 

### DI보다 우선하는 객체지향 개발
> 계층형 아키텍처 관점과 객체지향 설계 관점 에서 <u>***핵심적인 비즈니스 로직을 구현하는 역할은 누가 담당해야 할까?***</u>

```java
[...testcode...]
```

간단한 로직을 구현하는데 이정도의 테스트 코드를 작성해야 한다면 누가 테스트 코드를 작성하려 할까?

좀더 간단히 테스트 할 수 있는 방법은 없을까?

해답은 객체지향 프로그래밍에 있다.

```java
[...좀 더 간단히 테스트할 수 있도록 리팩토링된 코드...]
```

로직처리를 담당하는 새로운 객체를 추출함으로써 역할을 분리하고, 덕분에 테스트 코드 또한 보다 간결하게 작성할 수 있었다.

그렇다면 처음의 질문에 어떻게 답할 수 있을 지 고민해보자. 컨트롤러, 서비스, 레포지토리, 도메인 클래스와 더불어 다양하게 계층화된 애플리케이션의 
레이어 중에서 어느 레이어가 담당하는 것이 객체지향적인 개발이라고 할 수 있을까? 많은 개발자들이 서비스 레이어에서 핵심적인 비즈니스 로직을 처리하려고 한다.
하지만 사실 이는 서비스 레이어의 역할에 맞지 않다. ***핵심적인 비즈니스 로직 구현은 도메인 객체***가 하는 것이 맞다.
오히려 서비스 레이어의 역할은 핵심 로직들이 구현되어 있는 도메인 객체를 조립하고, DAO를 활용 하는 것에 초점이 맞춰져야 한다.

그렇지 않고 서비스 레이어에서 비즈니스 로직을 구현하려고 하는 것은 사실 절차지향적인 개발에 더 가까우며, 서비스 레이어의 복잡도는 그만큼 증가하여 
유지보수와 테스트하기 힘든 상황이 발생하게 될 것이다.

또한 핵심 객체라고 할 수 있는 도메인 객체는 사용자가 입력한 데이터를 DAO에 전달하거나 데이터베이스로부터 데이터를 전달받아 뷰에 전달하는 역할밖에 
하지 않게 된다. 단순히 setter, getter 메서드만 가지고 있는 것이 아니라 도메인 객체가 더 많은 일을 수행할 수 있도록 메세지를 전달하며 처리하도록 해보자.

도메인 객체로 로직을 이동했을 때의 이점은 여러 객체가 서로 협력하면서 로직을 구현할 수 있다는 것이다.
객체지향 개발을 하기 위한 좋은 연습은 상태값을 가지는 도메인 객체에서 값을 꺼내려 하지말고 
객체에 메시지를 보내 작업을 위임한다는 생각으로부터 시작할 수 있다. 
또한 테스트가 습관화되어 있지 않다면 다른 레이어에 대한 테스트는 진행하지 않도라도 도메인 객체에 대한 테스트는 반드시 해보길 권장한다.
도메인 객체를 테스트하기 쉬운 코드로 만드는 노력은 자연스럽게 좀 더 객체지향적인 코드를 구현할 수 있도록 도와줄 것이다.
 

