# 객체지향 설계 5원칙
<u>***목차***</u>
- [SRP(Single Responsibility Principle)](#srp-single-responsibility-principle-)
- [OCP(Open Closed Principle)](#ocp-open-closed-principle-)
- [LSP(Liskov Substitution Principle)](#lsp-liskov-substitution-principle-)
- [ISP(Interface Segregation Principle)](#isp-interface-segregation-principle-)
- [DIP(Dependency Inversion Principle)](#dip-dependency-inversion-principle-)


객체지향 설계 5원칙(SOLID)은 응집도는 높이고, 결합도는 낮추라는 고전 원칙을 객체 지향의 관점에서 재정립한 것이다. 
<u>***결합도***</u>란 모듈(클래스)간의 상호 의존 정도로서 결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이하다.
데이터 결합도, 스탬프 결합도, 컨트롤 결합도, 외부 결합도, 공유 결합도, 내용 결합도를 예로 들 수 있다.
<u>***응집도***</u>란 하나의 모듈 내부에 존재하는 구성 요소들간의 기능적 관련성으로, 
응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 용이하다.
기능 응집도, 통신 응집도, 절차 응집도, 시간 응집도, 논리 응집도, 우연 응집도가 그 예이다.

SOLID는 객체 지향 프로그램을 구성하는, 속성, 메서드, 클래스, 객체, 패키지, 모듈, 라이브러리, 프레임크, 아키텍처 등 
다양한 곳에 다양하게 적용된다. SOLID는 객체 지향 4대 특성을 발판으로 하고 디자인 패턴의 뼈대이며 스프링 프레임워크의 근간이기도 하다. 
# SRP(Single Responsibility Principle)
***단일 책임 원칙***이라고도 하며 로버트.C.마틴의 다음 격언이 SRP 원칙의 유명한 격언이다.
> 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.

예를 들어 연필 클래스와 연필이라고 하는 클래스에 의존하는 다양한 클래스가 있다고 해보자. 그래서 연필에는 다음과 같은 메서드들이 있다.

```java
class 연필{
    String type; // weapon, study, drawing
    int length;
    int thickness;
    int offensePower;
  
    public void 찌르기(){ ... }
    public void 휘두르기(){ ... }
    public void 낙서하기(){ ... }
    public void 글쓰기(){ ... }
    public void 스케치하기(){ ... }
    public void 드로잉하기(){ ... }
}
```
위에 예시로든 연필클래스에는 다음과 같은 역할과 그 역할을 수행하기 위한 각각의 메서드들이 있는 것이다.

| 역할 | 메서드 |
|---|---|
| **흉기** | 찌르기(),  휘두르기() |
| **공부** | 낙서하기(),  글쓰기() |
| **그림** | 스케치하기(),  드로잉하기() |

똑같은 연필일 뿐이지만 어떤 역할로 수행되냐에 따라서 아예 다른 용도로 사용이되는 것을 알 수 있다. 이와 같이 클래스가 하나의 역할만을 수행하는 것이 아니고 
여러 책임을 가지고 있을 때 객체지향에서는 나쁜 냄새가 난다고 한다. 오직 하나의 이유로만 클래스를 수정하기 위해선 클래스가 하나의 역할과 책임만 가질 수 있도록
***역할과 책임***이라는 기준에 따라 클래스를 쪼개야 하는 것이다.

위의 연필클래스를 흉기용연필, 공부용연필, 그림용연필 클래스로 분리하고 흉기용연필 클래스에서만 offensePower 필드를 갖게 하면 단일 책임 원칙이 적용되는 것이다.
클래스를 분리했을 때 분리된 클래스간에 공통된 특성이 있다면 연필 클래스는 제거할 수도 있다.

하나의 속성이 여러 의미를 갖는 경우도 단일 책임 원칙을 지키지 못하는 경우이다. 예를 들어 thickness 필드가 연필의 굵기를 나타낼 때, 
심의 굵기를 나타낼 때의 의미를 둘다 가진다면 소스 코드 상에서 if 문을 덕지덕지 사용해야 하는 상황이 발생하게 될 것이다.

그다음으로 낙서하기() 메서드를 통해 메서드 수준의 SRP를 생각해보자.
```java
public void 낙서하기(){
    if (this.type.equals("drawing")){
        // --- 자화상을 그린다.
    } else if (this.type.equals("study")) {
        // --- 각종 도형을 그린다.
    }
}
```
낙서하기() 메서드는 공부용도도 사용할떄와 그림용도로 사용할 때의 동작이 다른데 하나의 메서드에서 두가지 행위를 모두 구현하고 하기 때문에
SRP를 위반하고 있는 것이다. 이를 역할별로 클래스를 쪼갠다면 각각 쪼갠 메서드에서 하나의 책임만 수행하는 메서드를 구현할 수 있을 것이다.

적절한 예시를 생각하다가 어쩌다 연필이라 클래스로 억지스러운로 예시를 계속 사용하게 되었는데, 충분히 전달되지 않았다면 독자들이 직접 예시를 고민해보며 SRP에 대한 
개념을 좀 더 다질 수 있길 바란다.

> 단일 책임 원칙은 객체 지향 4대 특성 중 추상화와 가장 관계가 깊다. 리팩토링을 진행할 때, 애플리케이션의 경계를 정하고 추상화를 통해 
> 클래스들의 속성과 메서드를 설계할 때, 단일 책임 원칙에 위배되지 않도록 짜는 사고습관이 요구된다.

# OCP(Open Closed Principle)
개방 폐쇄 원칙
# LSP(Liskov Substitution Principle)
리스코프 치환원칙
# ISP(Interface Segregation Principle)
인터페이스 분리 원칙
# DIP(Dependency Inversion Principle)
의존 역전 원칙