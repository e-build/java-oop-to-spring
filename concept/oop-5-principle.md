# 객체지향 설계 5원칙
<u>***목차***</u>
- [SRP(Single Responsibility Principle)](#srpsingle-responsibility-principle)
- [OCP(Open Closed Principle)](#ocpopen-closed-principle)
- [LSP(Liskov Substitution Principle)](#lspliskov-substitution-principle)
- [ISP(Interface Segregation Principle)](#ispinterface-segregation-principle)
- [DIP(Dependency Inversion Principle)](#dipdependency-inversion-principle)


객체지향 설계 5원칙(SOLID)은 응집도는 높이고, 결합도는 낮추라는 고전 원칙을 객체 지향의 관점에서 재정립한 것이다. 
<u>***결합도***</u>란 모듈(클래스)간의 상호 의존 정도로서 결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객체의 재사용이나 수정, 유지보수가 용이하다.
데이터 결합도, 스탬프 결합도, 컨트롤 결합도, 외부 결합도, 공유 결합도, 내용 결합도를 예로 들 수 있다.
<u>***응집도***</u>란 하나의 모듈 내부에 존재하는 구성 요소들간의 기능적 관련성으로, 
응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용이나 기능의 수정, 유지보수가 용이하다.
기능 응집도, 통신 응집도, 절차 응집도, 시간 응집도, 논리 응집도, 우연 응집도가 그 예이다.

SOLID는 객체 지향 프로그램을 구성하는, 속성, 메서드, 클래스, 객체, 패키지, 모듈, 라이브러리, 프레임크, 아키텍처 등 
다양한 곳에 다양하게 적용된다. SOLID는 객체 지향 4대 특성을 발판으로 하고 디자인 패턴의 뼈대이며 스프링 프레임워크의 근간이기도 하다. 
# SRP(Single Responsibility Principle)
***단일 책임 원칙***이라고도 하며 로버트.C.마틴의 다음 격언이 SRP 원칙의 유명한 격언이다.
> 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.

예를 들어 연필 클래스와 연필이라고 하는 클래스에 의존하는 다양한 클래스가 있다고 해보자. 그래서 연필에는 다음과 같은 메서드들이 있다.

```java
class 연필{
    String type; // weapon, study, drawing
    int length;
    int thickness;
    int offensePower;
  
    public void 찌르기(){ ... }
    public void 휘두르기(){ ... }
    public void 낙서하기(){ ... }
    public void 글쓰기(){ ... }
    public void 스케치하기(){ ... }
    public void 드로잉하기(){ ... }
}
```
위에 예시로든 연필클래스에는 다음과 같은 역할과 그 역할을 수행하기 위한 각각의 메서드들이 있다.

| 역할 | 메서드 |
|---|---|
| **흉기** | 찌르기(),  휘두르기() |
| **공부** | 낙서하기(),  글쓰기() |
| **그림** | 스케치하기(),  드로잉하기() |

연필이라고 하는 하나의 사물을 나타내는 클래스일뿐이지만 어떤 역할로 수행되냐에 따라서 아예 다른 용도로 사용 되는 것을 알 수 있다. 이와 같이 클래스가 하나의 역할만을 수행하는 것이 아니고 
여러 책임을 가지고 있을 때 객체지향에서는 나쁜 냄새가 난다고 한다. 오직 하나의 이유로만 클래스를 수정하기 위해선 클래스가 하나의 역할과 책임만 가질 수 있도록
***역할과 책임***이라는 기준에 따라 클래스를 쪼개야 하는 것이다.

위의 연필클래스를 흉기용연필, 공부용연필, 그림용연필 클래스로 분리하고 흉기용연필 클래스에서만 offensePower 필드를 갖게 하면 단일 책임 원칙이 적용되는 것이다.
클래스를 분리했을 때 분리된 클래스간에 공통된 특성이 있다면 공통된 특성을 가진 연필클래스를 상위클래스로 둘 수 있지만, 공통된 특성이 없다면 연필 클래스는 제거할 수도 있다.

하나의 속성이 여러 의미를 갖는 경우도 단일 책임 원칙을 지키지 못하는 경우이다. 예를 들어 thickness 필드가 연필의 굵기를 나타낼 때, 
심의 굵기를 나타낼 때의 의미를 둘 다 가진다면 소스 코드 상에서 if 문을 덕지덕지 사용해야 하는 상황이 발생하게 될 것이다.

그 다음으로 낙서하기() 메서드를 통해 메서드 수준의 SRP를 생각해보자.
```java
public void 낙서하기(){
    if (this.type.equals("drawing")){
        // --- 눈 앞의 사물을 그린다.
    } else if (this.type.equals("study")) {
        // --- 각종 도형을 그린다.
    }
}
```
낙서하기() 메서드는 공부용도로 사용할 때와 그림용도로 사용할 때의 동작이 다른데 하나의 메서드에서 두 가지 행위를 모두 구현하려 하기 때문에
SRP를 위반하고 있다고 볼 수 있다. 이를 역할별로 클래스를 쪼갠다면 쪼개진 각각의 클래스 내부의 메서드에서 하나의 책임만 수행하도록 구현할 수 있을 것이다.

적절한 예시를 생각하다가 어쩌다 연필이라 클래스로 다소 억지스러운 예시를 계속 사용하게 되었는데, 충분히 전달되지 않았다면 독자들이 직접 예시를 고민해보며 SRP에 대한 
개념을 좀 더 다질 수 있길 바란다.

> 단일 책임 원칙은 객체 지향 4대 특성 중 추상화와 가장 관계가 깊다. 리팩토링을 진행할 때, 애플리케이션의 경계를 정하고 추상화를 통해 
> 클래스들의 속성과 메서드를 설계할 때, 단일 책임 원칙에 위배되지 않도록 짜는 사고습관이 요구된다.

# OCP(Open Closed Principle)
개방 폐쇄 원칙이라고도 하며, 자신의 확장에는 열려있지만 환경의 변화에는 폐쇄적으로 설계하는 것을 의미한다. 즉, 기존의 코드를 변경하지 않으면서 기능을 확장할 수 있도록 설계가 되어야 한다는 의미이다.
"개방"과 "폐쇄"라고 하는 단어의 역설때문에 처음 이해하는 입장에서 상당히 난해할 수 있다. 다음 예를 살펴보자.
<table>
    <thead>
        <tr>
            <th>클래스</th>
            <th>메서드</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan=2> A 엘레베이터 회사</td>
            <td>문을 좌우로 개방하다()</td>
        </tr>
        <tr>
            <td>이동하다()</td>
        </tr>
        <tr>
            <td rowspan=2>B 엘레베이터 회사</td>
            <td>문을 위아래로 개방하다()</td>
        </tr>
        <tr>
            <td>이동하다()</td>
        </tr>
    </tbody>
</table>
위와 같이 두 개의 엘레베이터 회사가 있고, 탑승자는 엘레베이터를 이용할 때 마다 문이 열리는 방식이 각기 다르게 동작하는 엘레베이터를 이용해야 한다.
현실세계에서는 그리 큰 문제가 아닐 수도 있지만, 객체지향 세계에서는 이러한 변화와 특성들이 적절히 추상화 되지 않았을 때 아주 복잡한 코드를 양산하게 된다.  
OCP 원칙은 이러한 변화에 대해 사용자가 일일이 대응하지 않도록 하는 해법을 제시한다.

<table>
    <thead>
        <tr>
            <th>인터페이스</th>
            <th>메서드</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="2"> 엘레베이터 </td>
            <td > 문을 개방하다() </td>
        </tr>
        <tr>
            <td > 이동하다() </td>
        </tr>
    </tbody>
</table>

엘레베이터라는 인터페이스를 만들어서 A, B 엘레베이터 회사들이 해당 인터페이스를 구현하게 한다. 그렇다면 엘레베이터를 이용하는 사용자의 입장에선 
어떤 회사의 엘레베이터를 사용하는 지 알 필요없이 단순히 `문을 개방하다()`,`이동하다()` 메서드를 통해 엘레베이터를 동작시킬 수 있게 되는 것이다.
다양한 엘레베이터 회사들이 추가된다고 하더라도 엘레베이터 인터페이스 입장에서는 자신의 확장에는 개방되어 있는 것이고, 사용자의 입장에서는 주변의 변화에 폐쇄되어 있다고 할 수 있는 것이다.

자바에서도 이러한 OCP 원칙을 토대로 설계된 유용한 API들을 제공하고 있는데, 그 중 좋은 예가 JDBC(Java Database Connectivity) API이다.
JDBC를 구현하여 각각의 DB벤더사(MySQL, MSSQL, Oracle, ...)들이 데이터베이스 커넥션을 제공하지만 JDBC 사용자의 입장에서는 Connection을 설정하는 것 외에는 
DB 벤더사에 따라 API를 다른 방식으로 사용하지 않을 수 있다. 

개방 폐쇄 원칙을 따르지 않는다고 해서 객체 지향 프로그램을 구현하는 것이 불가능한 것은 아니지만, 객체지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 얻을 수 없다.
스프링 프레임워크와 같은 좋은 프레임워크일수록 개방-폐쇄 원칙을 교과서적으로 활용하고 있음을 확인할 수 있다.

# LSP(Liskov Substitution Principle)
> 서브 타입은 언제나 자신의 기반 타입(Base Type)으로 교체할 수 있어야 한다. - 로버트 C.마틴
 
상속에 대해 설명하면서 객체 지향의 상속은 다음의 조건을 만족해야 한다고 전달한 바 있다.
* 하위 클래스 is a kind of 상위 클래스
* 구현 클래스 is able to 인터페이스

위 두개의 문장대로 구현된 프로그램이라면 이미 리스코프 치환원칙을 잘 지키고 있다고 할 수 있다. 
# ISP(Interface Segregation Principle)
> 클라이언트는 자신이 사용하지 않는 메서드에 의존관계를 맺어서는 안된다. - 로버트 C.마틴

인터페이스 분리 원칙이라고도하며, 경우에 따라 특정 역할만 수행할 수 있도록 강제하는 기능 제공하는 설계라고 할 수 있다. 
특정 인터페이스를 구현하는 클래스는 강제적으로 인터페이스의 메서드들을 구현해야만 한다. 따라서 인터페이스를 통해 메서드를 외부에 제공할 때는 
최소한의 메서드만 제공하라는 것이 ISP 원칙에 따른 설계에서 정말 중요한 점이다. 다음의 예를 살펴보자.

<<<--예시-->>>

SRP와 ISP는 같은 문제에 대한 두 가지의 다른 해결책이라고 할 수 있는데, 프로젝트 요구사항과 설계자의 취향에 따라 단일 책임 원칙이나 
인터페이스 분할 원칙 중 하나를 선택해서 설계할 수 있다. 하지만 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책인 경우가 많다.  


같은 문제에 대하여 SRP로 해결이 가능하기도 하고, ISP로 해결이 가능하기도 한 것이다. 
# DIP(Dependency Inversion Principle)
의존 역전 원칙이라고도 한다. 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것이다. 
한마디로 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺으라는 것이다.
