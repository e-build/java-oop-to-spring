***목차***
- [객체지향은 인간지향이다](#객체지향은-인간지향이다)
    + [객체지향은 어떻게 등장했나](#객체지향은-어떻게-등장했나)
    + [객체지향의 4대 특성](#객체지향의-4대-특성)
    + [그렇다면 객체란?](#객체란?)
- [추상화(Abstraction)](#추상화(Abstraction))
    + [프로그래밍에서 추상화란](#객체지향-프로그래밍에서-추상화란?)
    + [추상화와 T 메모리](#추상화와-T-메모리)
    + [static 멤버와 인스턴스 멤버](#static-멤버와-인스턴스-멤버)
- [상속](#상속)
    + [다중 상속과 자바](#다중-상속과-자바)
    + [상속과 인터페이스](#상속과-인터페이스)
    + [상속과 T 메모리](#상속과-T-메모리)
- [다형성](#다형성)
    + [다형성과 T 메모리](#다형성과-T-메모리)
- [캡슐화](#캡슐화)
- [참조변수의 복사](#참조변수의-복사)

  
# 객체지향은 인간지향이다
### 객체지향은 어떻게 등장했나
프로그래밍 언어의 역사를 살펴보면 개발자를 더욱 편하고 이롭게 하기 위한 과정에 따른 발전사임을 알 수 있다. 기계어, 어셈블리어, C, C++ 그리고 자바로 이르기까지의 과정은 
"왜 우리가 기계 종속적인 개발을 해야 하는가?"에 대한 의문과 "우리가 생활하는 현실세계를 투영하는 프로그래밍을 할 수 없을까?"라는 고민에 대한 결과인 것이다. 
현실 세계의 모든 사물들이 프로그래밍 세계에서는 하나의 객체이며, <span style="color:red"><b><i>프로그래밍을 통해 내가 창조하려는 이 세계의 객체들이 어떻게 상호작용할 것인가를 고민하는 것이 바로 "객체지향 프로그래밍"</i></b></span>인 것이다.
* 현실의 모든 사물은 프로그래밍에서는 객체로 표현할 수 있다.
* 각각의 사물은 고유하다
* 사물은 속성과 행위를 갖는다.

예를 들어 자동차라는 분류 안의 객체들은 타이어, 본체, 백미러, 연비 등과 같은 속성(property)을 가지며, 타이어를 움직이다, 백미러를 접다, 선루프를 열다와 같은 행위(method)를 가지고 있다.
이처럼 객체지향의 등장은 프로그램을 설계하고 구현, 분석하는 과정에서 시스템의 단위를 객체라는 기준으로 인지하고 분석함으로써 인간의 입장에서 직관적이고 쉽게 프로그래밍 할 수 있는 계기가 되었다고 볼 수 있는 것이다.  

### 객체지향의 4대 특성
* <b><i><u>캡슐화 [정보은닉]</u></i></b>
* <b><i><u>상속 [재사용]</u></i></b>
* <b><i><u>추상화 [모델링]</u></i></b>
* <b><i><u>다형성 [사용 편의]</u></i></b>
### 객체란?
흔히 객체지향을 설명하면서 클래스와 객체를 붕어빵틀과 붕어빵의 관계에 빗대어 말하곤 하는데 이것은 초보자에게 오히려 잘못된 개념을 심어줄 수 있다.
객체지향의 등장을 살펴보면서 자동차라는 분류가 가지고 있는 속성과 행위들을 알아봤는데, 이 때 클래스와 객체를 구분하는 좋은 방법은 구체적인 속성의 값을 질문해보는 것이다.
예를 들어 "자동차는 연비가 얼마인가"라고 물으면 답할 방법이 없다. 반면, "모닝의 연비는 얼마인가?"라고 물으면 금방 답할 수 있을 것인데, 이처럼 구체적인 속성의 값을 가지고 있으며, 
그에 따라 행위(동작, method)가 이루어질 수 있는 실체가 바로 객체인 것이다. 
> 클래스는 분류에 대한 개념이고 객체는 실체이다. 

그럼 다시 붕어빵틀과 붕어빵에 대한 이야기로 돌아가자면, 이것은 어떤 관계로 해석할 수 있을까? 
가장 근접한 답안을 찾차면 붕어빵틀은 객체를 생성해내는 팩토리를 의미하고 붕어빵은, 팩토리에 의해 생성된 객체의 관계로 이해하는 것이 가능할 것 같다. 팩토리 패턴에 대한 것은 추후 디자인 패턴에서 다루게 될 것이다.

# 추상화(Abstraction)
### 객체지향 프로그래밍에서 추상화란?
추상화라는 표현은 반드시 IT 분야의 기술 용어로써만 사용되는 것이 아님은 누구나 알 것이다. 
일상에서도 모호한 표현을 하는 친구에게 "말이 너무 추상적이다."라는 식으로 이야기하곤 하는 데, 이는 친구가 말하는 내용의 실체를 이해할 수 없다는 의미로 해석할 수 있다. 또한
추상화의 대가로 알려진 피카소의 그림은 사물을 사실 그대로 표현하기 보단 사물의 특징을 극대화해서 표현하는 것으로 잘 알려져 있다. 그렇다면 프로그래밍에서의 추상화란 무엇일까?
우선 추상화의 사전적의미는 다음과 같다.
> <b><i><u>추상화</u></i></b>   
> [명사][심리] 여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용

대화의 맥락이나 특정 분야에서 단어가 사용되는 컨텍스트에 따라 약간의 의미 차이는 존재 하겠지만, 결과적으로 <b><i><u>추상화란 사물의 구체적인 실체는 모르지만, 공통된 특성을 추출하여 파악하는 작용인 것</u></i></b>이다.
따라서 객체지향 프로그래밍에서 추상화란 아직 실체가 되지 않았지만 프로그램에서 객체로써 존재할 사물들의 공통된 특징들을 추출하고 모델링하는 작업이라고 볼 수 있을 것이다. 

그렇다면 추상화의 관점에서 보았을 때 우리는 프로그래밍 과정에서 다음과 같은 질문들을 통해 보다 객체지향적으로 설계하는 것이 가능해질 것이다.
> 1. 내가 창조하려는 세상은 어떤 세상인가? => 애플리케이션의 관심영역
> 2. 각각의 객체들은 어떻게 추상화 할 수 있는가? => 클래스 설계
> 3. 객체들은 어떤 관계로써 존재하는 가? => 넓은 의미의 추상화로써 상속, 인터페이스, 다형성을 고려하여 클래스 설계대해 고민할 수 있다.
### 추상화와 T 메모리
```
class Car {
  public String modelName;
  public int currentPrice;
  public int type;
  
  public void go(){
    System.out.println(this.name +  " 이(가) 움직입니다.");
  }
  
}

public class CarMain{

  public static void main(String[] args){
    Car morning = new Car();
    morning.modelName = "morning";
    morning.currentPrice = "10000";
    morning.type = "LIGHT";
    morning.go();
    morning = null;
    
    Car sportage = new Car();
    sportage.modelName = "sportage";
    sportage.currentPrice = "20000";
    sportage.type = "SUV";
    sportage.go()
  
  }
}
```
CarMain 클래스의 main()메서드가 시작할 시점에 T 메모리는 다음과 같을 것이다.
* static 영역: java.lang 패키지, Car 클래스 로딩
    - Car 클래스의 속성들은 스태틱영역에서 아직 값을 가지고 있지 않는데, 이는 클래스의 멤버가 아니라 인스턴스 멤버이기 때문이다. 
    - 클래스 멤버와 인스턴스 멤버는 static 키워드를 통해 구분한다.

morning 지역변수가 선언되고 객체를 할당하고, 이후에 null을 할당할 때 까지 T 메모리의 과정은 다음과 같다.
1. main() 메서드의 스택프레임에 morning 지역변수를 위한 메모리 공간이 생성된다.
2. new 연산자를 통해 새로운 Car 객체가 생성되고, 이 객체는 힙 영역에 메모리 공간이 생성된다.
3. 힙 영역에 존재하는 Car 객체의 메로리 주소값을 morning에 할당한다. 변수 morning이 새로 생성된 Car객체를 참조한다고 표현할 수 있다.
4. morning 에 . 이라는 참조 연산자를 사용해 실제 힙 영역에 있는 Car 객체에 접근하여, modelName, currentPrice, type에 값을 할당한다.
5. go() 를 실행하면 T 메모리 상의 변화는 없고, 코드 실행 영역에서 실행되어 콘솔에 "morning 이(가) 움직입니다." 가 출력된다.
6. morning 에 null 이 할당되면, 힙영역에 있는 Car 객체는 어느곳에서도 참조하지 않는 고아상태가 되고 이는 곧 JVM의 가비지 컬렉터가 수거한다.

다시 sportage 지역변수가 선언되고 새로운 Car 객체를 생성하여 할당하는 것을 볼 수 있는데, 이는 이전에 생성됐던 Car 객체가 아니라는 점을 알아야 한다.
따라서 인스턴스의 속성과 그에 따른 행위는 다르게 동작하게 되는 것이다. main() 메서드가 종료되면서 스택프레임이 소멸된다.

### 정적 멤버와 인스턴스 멤버
클래스 멤버, static 멤버, 정적 멤버 모두 다 같은 말이다. 또한 객체 멤버, 인스턴스 멤버, 오브젝트 멤버도 다 같은 말이다.
정적 속성인 경우 T 메모리의 스태틱 영역에 클래스가 배치될 때 클래스 내부에 메모리 공간이 확보된다. 이에 반해 인스턴스 속성은 속성명만 있고 실제 메모리 공간은 확보하지 않는다.
인스턴스 속성은 힙 영역에 객체가 생성되면 바로 그때 힙 영역내에 각각의 객체의 메모리 공간 안에 멤버 속성을 위한 메모리 공간이 할당된다.

<b><i><u>자바에서 변수의 세가지 유형</u></i></b>

|이름|다른 이름|T 메모리 배치|
|------|---|---|
|정적 변수|클래스 [멤버]속성, 정적 변수, 정적 속성|스태틱 영역|
|인스턴스 변수|객체 [멤버]속성, 객체 변수, ...|힙 영역|
|지역 변수|지역 변수|스택 영역 (스택프레임 내부)|

# 상속
> - 객체지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.
> - 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.
> - 객체 지향의 상속은 is a 관계가 아니라 is a kind of 관계를 만족해야 한다.
### 다중 상속과 자바
### 상속과 인터페이스
### 상속과 T 메모리

# 다형성
다형성은 사용편의성과 관계가 깊다.
### 다형성과 T 메모리

# 캡슐화
캡슐화는 정보은닉과 관계가 깊다. 자바는 접근제어자를 통해 캡슐화를 구현한다

# 참조변수의 복사

