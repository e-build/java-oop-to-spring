***목차***
- [객체지향은 인간지향이다](#객체지향은-인간지향이다)
    + [객체지향은 어떻게 등장했나](#객체지향은-어떻게-등장했나)
    + [객체지향의 4대 특성](#객체지향의-4대-특성)
    + [객체란?](#객체란?)
- [추상화(Abstraction)](#추상화(Abstraction))
    + [프로그래밍에서 추상화란](#객체지향-프로그래밍에서-추상화란?)
    + [추상화와 T 메모리](#추상화와-T-메모리)
    + [static 멤버와 인스턴스 멤버](#static-멤버와-인스턴스-멤버)
- [상속(Inheritance)](#상속(Inheritance))
    + [상속과 인터페이스](#상속과-인터페이스)
    + [상속과 T 메모리](#상속과-T-메모리)
- [다형성(Polymorphism)](#다형성(Polymorphism))
    + [다형성과 T 메모리](#다형성과-T-메모리)
- [캡슐화](#캡슐화)
- [참조변수의 복사](#참조변수의-복사)

  
# 객체지향은 인간지향이다
### 객체지향은 어떻게 등장했나
프로그래밍 언어의 역사를 살펴보면 개발자를 더욱 편하고 이롭게 하기 위한 과정에 따른 발전사임을 알 수 있다. 기계어, 어셈블리어, C, C++ 그리고 자바로 이르기까지의 과정은 
"왜 우리가 기계 종속적인 개발을 해야 하는가?"에 대한 의문과 "우리가 생활하는 현실세계를 투영하는 프로그래밍을 할 수 없을까?"라는 고민에 대한 결과인 것이다. 
현실 세계의 모든 사물들이 프로그래밍 세계에서는 하나의 객체이며, <span style="color:red"><b><i>프로그래밍을 통해 내가 창조하려는 이 세계의 객체들이 어떻게 상호작용할 것인가를 고민하는 것이 바로 "객체지향 프로그래밍"</i></b></span>인 것이다.
* 현실의 모든 사물은 프로그래밍에서는 객체로 표현할 수 있다.
* 각각의 사물은 고유하다
* 사물은 속성과 행위를 갖는다.

예를 들어 자동차라는 분류 안의 객체들은 타이어, 본체, 백미러, 연비 등과 같은 속성(property)을 가지며, 타이어를 움직이다, 백미러를 접다, 선루프를 열다와 같은 행위(method)를 가지고 있다.
이처럼 객체지향의 등장은 프로그램을 설계하고 구현, 분석하는 과정에서 시스템의 단위를 객체라는 기준으로 인지하고 분석함으로써 인간의 입장에서 직관적이고 쉽게 프로그래밍 할 수 있는 계기가 되었다고 볼 수 있는 것이다.  

### 객체지향의 4대 특성
* <b><i><u>캡슐화 [정보은닉]</u></i></b>
* <b><i><u>상속 [재사용]</u></i></b>
* <b><i><u>추상화 [모델링]</u></i></b>
* <b><i><u>다형성 [사용 편의]</u></i></b>
### 객체란?
흔히 객체지향을 설명하면서 클래스와 객체를 붕어빵틀과 붕어빵의 관계에 빗대어 말하곤 하는데 이것은 초보자에게 오히려 잘못된 개념을 심어줄 수 있다.
객체지향의 등장을 살펴보면서 자동차라는 분류가 가지고 있는 속성과 행위들을 알아봤는데, 이 때 클래스와 객체를 구분하는 좋은 방법은 구체적인 속성의 값을 질문해보는 것이다.
예를 들어 "자동차는 연비가 얼마인가"라고 물으면 답할 방법이 없다. 반면, "모닝의 연비는 얼마인가?"라고 물으면 금방 답할 수 있을 것인데, 이처럼 구체적인 속성의 값을 가지고 있으며, 
그에 따라 행위(동작, method)가 이루어질 수 있는 실체가 바로 객체인 것이다. 
> 클래스는 분류에 대한 개념이고 객체는 실체이다. 

그럼 다시 붕어빵틀과 붕어빵에 대한 이야기로 돌아가자면, 이것은 어떤 관계로 해석할 수 있을까? 
가장 근접한 답안을 찾차면 붕어빵틀은 객체를 생성해내는 팩토리를 의미하고 붕어빵은, 팩토리에 의해 생성된 객체의 관계로 이해하는 것이 가능할 것 같다. 팩토리 패턴에 대한 것은 추후 디자인 패턴에서 다루게 될 것이다.

# 추상화(Abstraction)
### 객체지향 프로그래밍에서 추상화란?
추상화라는 표현은 반드시 IT 분야의 기술 용어로써만 사용되는 것은 아니다. 
일상에서도 모호한 표현을 하는 친구에게 "말이 너무 추상적이다."라는 식으로 이야기하곤 하는 데, 이는 친구가 말하는 내용의 실체를 이해할 수 없다는 의미로 해석할 수 있다. 또한
추상화의 대가로 알려진 피카소의 그림은 사물을 사실 그대로 표현하기 보단 사물의 특징을 극대화해서 표현하는 것으로 잘 알려져 있다. 그렇다면 프로그래밍에서의 추상화란 무엇일까?
우선 추상화의 사전적의미는 다음과 같다.
> <b><i><u>추상화</u></i></b>   
> [명사][심리] 여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용

대화의 맥락이나 특정 분야에서 단어가 사용되는 컨텍스트에 따라 약간의 의미 차이는 존재 하겠지만, 결과적으로 <b><i><u>추상화란 사물의 구체적인 실체는 모르지만, 공통된 특성을 추출하여 파악하는 작용인 것</u></i></b>이다.
따라서 객체지향 프로그래밍에서 추상화란 아직 실체가 되지 않았지만 프로그램에서 객체로써 존재할 사물들의 공통된 특징들을 추출하고 모델링하는 작업이라고 볼 수 있을 것이다. 

그렇다면 추상화의 관점에서 보았을 때 우리는 프로그래밍 과정에서 다음과 같은 질문들을 통해 보다 객체지향적으로 설계하는 것이 가능해질 것이다.
> 1. 내가 창조하려는 세상은 어떤 세상인가? => 애플리케이션의 관심영역
> 2. 각각의 객체들은 어떻게 추상화 할 수 있는가? => 클래스 설계
> 3. 객체들은 어떤 관계로써 존재하는 가? => 넓은 의미의 추상화로써 상속, 인터페이스, 다형성을 고려하여 클래스 설계에 대해 고민할 수 있다.

예를 들어, 점심을 추천해주는 애플리케이션을 개발한다고 가정해보자. 추천해줄 수 있는 수많은 식당들이 있을 것이고, 각 식당별로 메뉴들이 존재할 것이다.
'점심을 추천해준다'는 애플리케이션의 관심영역에서 식당의 속성들을 뽑아보면 다음과 같은 속성들로 이루어진 클래스를 설계할 수 있을 것이다.
```java
class Restaurant {
  private final String name; // 음식점명
  private final String type; // 한식, 일식, 중식, 양식, 분식 등 
  private final String tel; // 식당 연락처
  private final double grade; // 별점
  private final int staffCount; // 직원 수 
  private final LocalTime breakTimeStart; // 브레이크 타임 시작 시간
  private final LocalTime breakTimeEnd; // 브레이크 타임 종료 시간
  private final List<Menu> menuList; // 메뉴 
  ...
  
  public Restaurant(...){
    ...
  }
}

class Menu {
  private final String name; // 메뉴명
  private final String type; // 메뉴 분류 (한식, 일식, 중식, 양식, 분식 등) 
  private final double price; // 메뉴 가격
  private final double grade; // 별점
  private final int numberOfSalesPerDay; // 일 판매 수량 
  private final boolean isSignature; // 시그니처 메뉴 여부
  ...

  public Menu(...){
    ...
  }
}
```
위의 Restaurant 클래스에서 과연 모든 필드들이 정말 필요한 지 다시 고민해보자. 점심추천 앱에서 식당을 표현하는데 사용되는 클래스를 설계할 때, 식당의 '직원 수'를 알 필요가 있을까? 
만약 식당의 인적/물적 자원들을 관리하는 애플리케이션이었다면 '직원 수'는 충분히 관심영역 내에 있었을 것이다. 또한 '점심 식사'라고 하는 11:00~13:00 사이의 특정 시간대를 타겟으로 하는 
상황에서 '브레이크 타임'의 시작시간, 종료시간이 정말 필요할까? 만약 비즈니스가 확장되어, 사용자가 원하는 시간대를 지정하고 식사를 추천 해주는 어플리케이션이라고 한다면 식당들의 '브레이크 타임'은 
중요한 속성이 될 수 있을 것이다. 이와 같이 애플리케이션이 어떠한 맥락에서 활용되고자 하는 지에 따라, 동일한 사물에 대한 추상화라 할 지라도 추출되는 속성들에 대한 차이가 존재하며, 클래스들 간의
관계 또한 다르게 정의될 것이다.

# 상속(Inheritance)
객체지향의 상속은 '상속'이라는 단어 그대로의 의미보다 '재사용'과 '확장'이라는 의미로 이해하는 것이 옳다. 다음은 상속 관계에서 반드시 만족해야 할 문장이다. 
> 하위 클래스는 상위 클래스다. 

다음의 예를 보면 상속이라는 단어 그대로 의미를 이해하는 것이 왜 옳지 않은지 알 수 있을 것이다.

> - 아버지는 할아버지다.
> - 아들은 아버지다.

언뜻 봐도 말이 안되지만, 분류의 차원에서 클래스를 이해할 때 다음의 문장은 단번에 이해할 수 있을 것이다.
> - sportage는 SUV다.
> - SUV는 차량이다.
> - sportage는 차량이다.

즉 객체지향에서 상속이란 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 속성을 추가, 즉 확장해서 사용할 수 있다는 의미이다. 
상위 클래스 쪽으로 갈수록 추상화, 일반화 됐다고 말하며, 하위 클래스 쪽으로 갈수록 구체화, 특수화됐다고 말할 수 있다.

`하위 클래스는 상위 클래스다` 라는 표현이 실제 코드상에서 어떻게 표현되고 활용될 수 있는 지 확인해보자.
```java
public class CarMain{
    
    public static void main(String[] args){
      Car[] carList = new Car[5];
      car[0] = new Sportage();
      car[1] = new Morning();
      car[2] = new Suv();
      car[3] = new Light();
      car[4] = new Sedan();
      
      for (Car car : carList){
          car.printName();
      }
    }
}
```
Car 타입의 크기가 5인 배열을 선언하고 Car 클래스를 상속하는 클래스들의 인스턴스를 생성하여 할당하였다. 그리고 반복문을 통해 각 인스턴스의 printName을 호출하면
각 하위클래스별로 본인들의 이름을 출력할 것 이다. 

> ***<u>다중 상속과 자바</u>***
> 
> 자바는 다중 상속을 지원하지 않는다. "사람"과 "물고기" 클래스를 상속하는 인어클래스를 가정해보자. 
사람도 수영할 수 있고, 물고기도 수영할 수 있는데 인어에게 수영하라고 지시한다면 인어는 사람과 물고기의 수영방식 중 어떤 것을 따라야 할까?
이와 같은 문제를 다중 상속의 다이아몬드 문제라고 했고, 결국 득보다 실이 더 많았기에 자바는 다중상속을 포기했다고 한다.

***정리***
> - 객체지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.
> - 객체지향의 상속은 상위 클래스의 특성을 확장하는 것이다.
> - 객체지향의 상속은 is a 관계가 아니라 is a kind of 관계를 만족해야 한다.

### 상속과 인터페이스
클래스와 인터페이스의 관계는 be able to 의 의미로 표현할 수 있다. 다음의 자바 API 예를 보자.
* Serializable 인터페이스 : 직렬화할 수 있는
* Cloneable 인터페이스 : 복제할 수 있는
* Comparable 인터페이스 : 비교할 수 있는
* Runnable 인터페이스 : 실행할 수 있는

자바 API에서도 인터페이스의 이름에 able이라는 접미어를 붙임으로써 의미적으로 인터페이스가 클래스에 어떤 기능을 부여하고 있는 지 암시하고 있다.
또한 해당 인터페이스들을 구현(implements)하면, 각각의 인터페이스들에서 강제하는 메서드들을 하위클래스에서 구체적으로 구현해야만 인터페이스에서 제공하는 기능들을
오류없이 사용할 수 있다.

상위 클래스는 하위 클래스에게 멤버(속성과 메서드)를 상속해주고, 인터페이스는 클래스가 '무엇을 할 수 있다.'라고 하는 기능을 구현하도록 강제하는 것이다.
상위 클래스는 물려줄 멤버가 풍부할수록 좋고, 인터페이스는 구현을 강제할 메서드의 개수가 적을 수록 좋다. 이는 객체 지향 설계 5원칙 중에서 
상속의 풍부함은 LSP(리스코프 치환 원칙)에 따른 이유이고, 인터페이스의 메서드가 적을 수록 좋은 이유는 ISP(인터페이스 분할 원칙)에 따른 이유이다.  

# 다형성(Polymorphism)
다형성은 사용편의성과 관계가 깊다. 객체지향에서 다형성이라 하면 overriding과 overloading이라고 할 수 있다.
* Overriding (오버라이딩): 같은 메서드 이름, ***같은 인자*** 목록으로 상위 클래스의 메서드를 ***재정의*** 
* Overloading (오버로딩): 같은 메서드 이름, ***다른 인자*** 목록으로 다수의 메서드를 ***중복 정의***

```java
class CarMain {
    public static void main(String[] args){
        Car santafe = new Suv();
        santafe.modelName = "santafe";
        santafe.currentPrice = 10000;
        santafe.trunkSize = 500;

        santafe.printTrunkSize();    // 500
        santafe.printTrunkSize(200); // 700
        santafe.go();                // santafe 이(가) 공기의 저항을 강하게 받으며 움직입니다.
    }
}
```
상속에서 사용했던 예제를 그대로 사용해서 CarMain 클래스만 조금 바꿔보았다. printTrunkSize()메서드는 오버로딩하여 인자가 무항이거나 1개인 경우로 
사용 케이스를 분리하였고, go()메서드는 Suv클래스에서 오버라이딩, 즉 재정의하여 출력 텍스트를 조금 바꿔보았다. ***상위클래스 타입의 객체 참조 변수를 사용하더라도
하위 클래스에서 오버라이딩한 메서드가 호출***되어 "santafe 이(가) 공기의 저항을 강하게 받으며 움직입니다." 가 출력될 것이다.


# 캡슐화
캡슐화는 정보은닉과 관계가 깊다. 자바는 접근제어자를 통해 캡슐화를 구현한다. 접근 제어자가 인스턴스 멤버와 쓰일 때와 클래스 멤버와 함께 쓰일 때를 비교해서 살펴볼 필요가 있다.
* [-----이펙티브 자바로 정리-----]


# 참조변수의 복사
Call By Value와 Call By Reference를 다르다고 이해하기 보다는 기본 자료형 변수는 저장하고 값을 그 값 자체로 판단하고, 
참조 변수는 저장하고 있는 값을 주소로 판단한다고 이해하는것이 더 쉽다.
> - 기본 자료형 변수는 값을 값 자체로 판단한다.
> - 참조 자료형 변수는 값을 주소, 즉 포인터로 판단한다.
> - 기본 자료형 변수를 복사할 때, 참조 자료형 변수를 복사할 때 일어나는 일은 같다.
즉 가지고 있는 값을 그대로 복사해서 넘겨준다.

위와 같은 변수의 값을 복사하는 기준은 메서드 내부에서의 동작, 메서드의 인자나 반환값으로 사용되는 경우에 모두 동일하게 작용한다.

