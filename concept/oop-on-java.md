***목차***
- [객체지향은 인간지향이다](#객체지향은-인간지향이다)
    + [객체지향은 어떻게 등장했나](#객체지향은-어떻게-등장했나)
    + [객체지향의 4대 특성](#객체지향의-4대-특성)
    + [객체란?](#객체란?)
- [추상화(Abstraction)](#추상화(Abstraction))
    + [프로그래밍에서 추상화란](#객체지향-프로그래밍에서-추상화란?)
    + [추상화와 T 메모리](#추상화와-T-메모리)
    + [static 멤버와 인스턴스 멤버](#static-멤버와-인스턴스-멤버)
- [상속(Inheritance)](#상속(Inheritance))
    + [상속과 인터페이스](#상속과-인터페이스)
    + [상속과 T 메모리](#상속과-T-메모리)
- [다형성(Polymorphism)](#다형성(Polymorphism))
    + [다형성과 T 메모리](#다형성과-T-메모리)
- [캡슐화](#캡슐화)
- [참조변수의 복사](#참조변수의-복사)

  
# 객체지향은 인간지향이다
### 객체지향은 어떻게 등장했나
프로그래밍 언어의 역사를 살펴보면 개발자를 더욱 편하고 이롭게 하기 위한 과정에 따른 발전사임을 알 수 있다. 기계어, 어셈블리어, C, C++ 그리고 자바로 이르기까지의 과정은 
"왜 우리가 기계 종속적인 개발을 해야 하는가?"에 대한 의문과 "우리가 생활하는 현실세계를 투영하는 프로그래밍을 할 수 없을까?"라는 고민에 대한 결과인 것이다. 
현실 세계의 모든 사물들이 프로그래밍 세계에서는 하나의 객체이며, <span style="color:red"><b><i>프로그래밍을 통해 내가 창조하려는 이 세계의 객체들이 어떻게 상호작용할 것인가를 고민하는 것이 바로 "객체지향 프로그래밍"</i></b></span>인 것이다.
* 현실의 모든 사물은 프로그래밍에서는 객체로 표현할 수 있다.
* 각각의 사물은 고유하다
* 사물은 속성과 행위를 갖는다.

예를 들어 자동차라는 분류 안의 객체들은 타이어, 본체, 백미러, 연비 등과 같은 속성(property)을 가지며, 타이어를 움직이다, 백미러를 접다, 선루프를 열다와 같은 행위(method)를 가지고 있다.
이처럼 객체지향의 등장은 프로그램을 설계하고 구현, 분석하는 과정에서 시스템의 단위를 객체라는 기준으로 인지하고 분석함으로써 인간의 입장에서 직관적이고 쉽게 프로그래밍 할 수 있는 계기가 되었다고 볼 수 있는 것이다.  

### 객체지향의 4대 특성
* <b><i><u>캡슐화 [정보은닉]</u></i></b>
* <b><i><u>상속 [재사용]</u></i></b>
* <b><i><u>추상화 [모델링]</u></i></b>
* <b><i><u>다형성 [사용 편의]</u></i></b>
### 객체란?
흔히 객체지향을 설명하면서 클래스와 객체를 붕어빵틀과 붕어빵의 관계에 빗대어 말하곤 하는데 이것은 초보자에게 오히려 잘못된 개념을 심어줄 수 있다.
객체지향의 등장을 살펴보면서 자동차라는 분류가 가지고 있는 속성과 행위들을 알아봤는데, 이 때 클래스와 객체를 구분하는 좋은 방법은 구체적인 속성의 값을 질문해보는 것이다.
예를 들어 "자동차는 연비가 얼마인가"라고 물으면 답할 방법이 없다. 반면, "모닝의 연비는 얼마인가?"라고 물으면 금방 답할 수 있을 것인데, 이처럼 구체적인 속성의 값을 가지고 있으며, 
그에 따라 행위(동작, method)가 이루어질 수 있는 실체가 바로 객체인 것이다. 
> 클래스는 분류에 대한 개념이고 객체는 실체이다. 

그럼 다시 붕어빵틀과 붕어빵에 대한 이야기로 돌아가자면, 이것은 어떤 관계로 해석할 수 있을까? 
가장 근접한 답안을 찾차면 붕어빵틀은 객체를 생성해내는 팩토리를 의미하고 붕어빵은, 팩토리에 의해 생성된 객체의 관계로 이해하는 것이 가능할 것 같다. 팩토리 패턴에 대한 것은 추후 디자인 패턴에서 다루게 될 것이다.

# 추상화(Abstraction)
### 객체지향 프로그래밍에서 추상화란?
추상화라는 표현은 반드시 IT 분야의 기술 용어로써만 사용되는 것은 아니다. 
일상에서도 모호한 표현을 하는 친구에게 "말이 너무 추상적이다."라는 식으로 이야기하곤 하는 데, 이는 친구가 말하는 내용의 실체를 이해할 수 없다는 의미로 해석할 수 있다. 또한
추상화의 대가로 알려진 피카소의 그림은 사물을 사실 그대로 표현하기 보단 사물의 특징을 극대화해서 표현하는 것으로 잘 알려져 있다. 그렇다면 프로그래밍에서의 추상화란 무엇일까?
우선 추상화의 사전적의미는 다음과 같다.
> <b><i><u>추상화</u></i></b>   
> [명사][심리] 여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용

대화의 맥락이나 특정 분야에서 단어가 사용되는 컨텍스트에 따라 약간의 의미 차이는 존재 하겠지만, 결과적으로 <b><i><u>추상화란 사물의 구체적인 실체는 모르지만, 공통된 특성을 추출하여 파악하는 작용인 것</u></i></b>이다.
따라서 객체지향 프로그래밍에서 추상화란 아직 실체가 되지 않았지만 프로그램에서 객체로써 존재할 사물들의 공통된 특징들을 추출하고 모델링하는 작업이라고 볼 수 있을 것이다. 

그렇다면 추상화의 관점에서 보았을 때 우리는 프로그래밍 과정에서 다음과 같은 질문들을 통해 보다 객체지향적으로 설계하는 것이 가능해질 것이다.
> 1. 내가 창조하려는 세상은 어떤 세상인가? => 애플리케이션의 관심영역
> 2. 각각의 객체들은 어떻게 추상화 할 수 있는가? => 클래스 설계
> 3. 객체들은 어떤 관계로써 존재하는 가? => 넓은 의미의 추상화로써 상속, 인터페이스, 다형성을 고려하여 클래스 설계대해 고민할 수 있다.
### 추상화와 T 메모리
```java
class Car {
  public String modelName;
  public int currentPrice;
  public int type;
  
  public void go(){
    System.out.println(this.name +  " 이(가) 움직입니다.");
  }
  
}

public class CarMain{

  public static void main(String[] args){
    Car morning = new Car();
    morning.modelName = "morning";
    morning.currentPrice = "10000";
    morning.type = "LIGHT";
    morning.go();
    morning = null;
    
    Car sportage = new Car();
    sportage.modelName = "sportage";
    sportage.currentPrice = "20000";
    sportage.type = "SUV";
    sportage.go()
  
  }
}
```
CarMain 클래스의 main()메서드가 시작할 시점에 T 메모리는 다음과 같을 것이다.
* static 영역: java.lang 패키지, Car 클래스 로딩
    - Car 클래스의 속성들은 스태틱영역에서 아직 값을 가지고 있지 않는데, 이는 클래스의 멤버가 아니라 인스턴스 멤버이기 때문이다. 
    - 클래스 멤버와 인스턴스 멤버는 static 키워드를 통해 구분한다.

morning 지역변수가 선언되고 객체를 할당하고, 이후에 null을 할당할 때 까지 T 메모리의 과정은 다음과 같다.
1. main() 메서드의 스택프레임에 morning 지역변수를 위한 메모리 공간이 생성된다.
2. new 연산자를 통해 새로운 Car 객체가 생성되고, 이 객체는 힙 영역에 메모리 공간이 생성된다.
3. 힙 영역에 존재하는 Car 객체의 메모리 주소값을 morning에 할당한다. 변수 morning이 새로 생성된 Car객체를 참조한다고 표현할 수 있다.
4. morning 에 . 이라는 참조 연산자를 사용해 실제 힙 영역에 있는 Car 객체에 접근하여, modelName, currentPrice, type에 값을 할당한다.
5. go() 를 실행하면 T 메모리 상의 변화는 없고, 코드 실행 영역에서 실행되어 콘솔에 "morning 이(가) 움직입니다." 가 출력된다.
6. morning 에 null 이 할당되면, 힙영역에 있는 Car 객체는 어느곳에서도 참조하지 않는 고아상태가 되고 이는 곧 JVM의 가비지 컬렉터가 수거한다.

다시 sportage 지역변수가 선언되고 새로운 Car 객체를 생성하여 할당하는 것을 볼 수 있는데, 이는 이전에 생성됐던 Car 객체가 아니라는 점을 알아야 한다.
따라서 인스턴스의 속성과 그에 따른 행위는 다르게 동작하게 되는 것이다. main() 메서드가 종료되면서 스택프레임이 소멸된다.

### 정적 멤버와 인스턴스 멤버
클래스 멤버, static 멤버, 정적 멤버 모두 다 같은 말이다. 또한 객체 멤버, 인스턴스 멤버, 오브젝트 멤버도 다 같은 말이다.
T 메모리의 스태틱 영역에 클래스가 배치될 때 클래스 속성과 인스턴스 속성의 동작이 다른데, 클래스 속성인 경우 클래스 내부에 메모리 공간이 확보된다.
이에 반해 인스턴스 속성은 속성명만 있고 실제 메모리 공간은 확보되지 않는다. 
인스턴스 속성은 힙 영역에 객체가 생성되면 바로 그때 힙 영역내에 각각의 객체의 메모리 공간 안에 멤버 속성을 위한 메모리 공간이 할당된다.

<b><i><u>자바에서 변수의 세가지 유형</u></i></b>

|이름|다른 이름|T 메모리 배치|
|------|---|---|
|정적 변수|클래스 [멤버]속성, 정적 변수, 정적 속성|스태틱 영역|
|인스턴스 변수|객체 [멤버]속성, 객체 변수, ...|힙 영역|
|지역 변수|지역 변수|스택 영역 (스택프레임 내부)|

# 상속(Inheritance)
객체지향의 상속은 '상속'이라는 단어 그대로의 의미보다 '재사용'과 '확장'이라는 의미로 이해하는 것이 옳다. 다음은 상속 관계에서 반드시 만족해야 할 문장이다. 
> 하위 클래스는 상위 클래스다. 

다음의 예를 보면 상속이라는 단어그대로 의미를 이해하는 것이 왜 옳지 않은지 알 수 있을 것이다.

> - 아버지는 할아버지다.
> - 아들은 아버지다.

언뜻 봐도 말이 안되지만, 분류의 차원에서 클래스를 이해할 때 다음의 문장은 단번에 이해할 수 있을 것이다.
> - sportage는 SUV다.
> - SUV는 차량이다.
> - sportage는 차량이다.
> 
즉 객체지향에서 상속이란 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미이다. 
상위 클래스 쪽으로 갈수록 추상화, 일반화 됐다고 말하며, 하위 클래스 쪽으로 갈수록 구체화, 특수화됐다고 말할 수 있다.

`하위 클래스는 상위 클래스다`. 라는 표현이 실제 코드상에서 어떻게 표현되고 활용될 수 있는 지 확인해보자.
```java
public class CarMain{
    
    public static void main(String[] args){
      Car[] carList = new Car[5];
      car[0] = new Sportage();
      car[1] = new Morning();
      car[2] = new Suv();
      car[3] = new Light();
      car[4] = new Sedan();
      
      for (Car car : carList){
          car.printName();
      }
    }
}
```
Car 타입의 크기가 5인 배열을 선언하고 Car 클래스를 상속하는 클래스들의 인스턴스를 생성하여 할당하였다. 그리고 반복문을 통해 각 인스턴스의 printName을 호출하면
각 하위클래스별로 본인들의 이름을 출력할 것 이다. 


> ***<u>다중 상속과 자바</u>***
> 
> 자바는 다중 상속을 지원하지 않는다. "사람"과 "물고기" 클래스를 상속하는 인어클래스를 가정해보자. 
사람도 수영할 수 있고, 물고기도 수영할 수 있는데 인어에게 수영하라고 지시한다면 인어는 사람과 물고기의 수영방식 중 어떤 것을 따라야 할까?
이와 같은 문제를 다중 상속의 다이아몬드 문제라고 했고, 결국 득보다 실이 더 많았기에 자바는 다중상속을 포기했다고 한다.

***정리***
> - 객체지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.
> - 객체지향의 상속은 상위 클래스의 특성을 확장하는 것이다.
> - 객체지향의 상속은 is a 관계가 아니라 is a kind of 관계를 만족해야 한다.

### 상속과 인터페이스
클래스와 인터페이스의 관계는 be able to 의 의미로 표현할 수 있다. 다음의 자바 API 예를 보자.
* Serializable 인터페이스 : 직렬화할 수 있는
* Cloneable 인터페이스 : 복제할 수 있는
* Comparable 인터페이스 : 비교할 수 있는
* Runnable 인터페이스 : 실행할 수 있는

자바 API에서도 인터페이스의 이름에 able이라는 접미어를 붙임으로써 의미적으로 인터페이스가 클래스가 어떤 관계로 사용되도록 하는 지 암시하고 있다.
또한 해당 인터페이스들을 구현(implements)하면, 각각의 인터페이스들에서 강제하는 메서드들을 하위클래스에서 구체적으로 구현해야만 인터페이스에서 제공하는 기능들을
오류없이 사용할 수 있다.

상위 클래스는 하위 클래스에게 멤버(속성과 메서드)를 상속해주고, 인터페이스는 클래스가 '무엇을 할 수 있다.'라고 하는 기능을 구현하도록 강제하는 것이다.
상위 클래스는 물려줄 멤버가 풍부할수록 좋고, 인터페이스는 구현을 강제할 메서드의 개수가 적을 수록 좋다. 이는 객체 지향 설계 5원칙 중에서 
상속의 풍부함은 LSP(리스코프 치환 원칙)에 따른 이유이고, 인터페이스의 메서드가 적을 수록 좋은 이유는 ISP(인터페이스 분할 원칙)에 따른 이유이다.  

### 상속과 T 메모리
```java
class Car {
    String modelName;
    int currentPrice;
    
    public void go(){
      System.out.println(this.name +  " 이(가) 움직입니다.");
    }

}

```
```java
class Suv extends Car {
    int trunkSize;
  
    @Override
    public void go(){
      System.out.println(this.name +" 이(가) 공기의 저항을 강하게 받으며 움직입니다.");
    }
    
    public int printTrunkSize(){
      System.out.println(this.trunkSize);
    }

    public int printTrunkSize(int plusSize){
        this.trunkSize += 100;
        System.out.println(this.trunkSize);
    }
}
```
```java
class CarMain {
    
    public static void main(String[] args){
        Suv sportage = new Suv();
        sportage.modelName = "sportage";
        sportage.currentPrice = 10000;
        sportage.trunkSize = 500;
  
        sportage.printTrunkSize();
        sportage.go(); 

        Car santafe = new Suv();
        santafe.modelName = "santafe";
        santafe.currentPrice = 10000;
        santafe.trunkSize = 500;
    }
}
```
sportage와 santafe라고 하는 객체를 만들었다. 두 객체 모두 상속받고 있는 Suv 클래스의 인스턴스를 할당받기 때문에 힙메모리 상에서는
상위 클래스인 Car의 인스턴스와 하위 클래스인 Suv의 인스턴스가 함께 생성된다. 그렇다면 사실 유추해보길 모든 클래스의 최상의 클래스인 Object 클래스의
인스턴스도 함께 생성될 것이다. sportage와 santafe의 차이는 sportage는 Suv 타입이면서 Suv 클래스이 인스턴스를 할당받지만,
santafe는 Car 타입이면서 Suv 클래스의 인스턴스를 할당받는다는 것이다. 이는 힙메모리 상에 실제로 참조하는 인스턴스에 다르다는 차이가 있는데,
Suv 타입으로 선언된 sportage 는 Suv 클래스의 인스턴스를 참조하는 반면, Car 타입으로 선언된 santafe 는 Car 클래스의 인스턴스를 참조한다는 것이다.

# 다형성(Polymorphism)
다형성은 사용편의성과 관계가 깊다. 객체지향에서 다형성이라 하면 overriding과 overloading이라고 할 수 있다.
* Overriding (오버라이딩): 같은 메서드 이름, ***같은 인자*** 목록으로 상위 클래스의 메서드를 ***재정의*** 
* Overloading (오버로딩): 같은 메서드 이름, ***다른 인자*** 목록으로 다수의 메서드를 ***중복 정의***

```java
class CarMain {
    public static void main(String[] args){
        Car santafe = new Suv();
        santafe.modelName = "santafe";
        santafe.currentPrice = 10000;
        santafe.trunkSize = 500;

        santafe.printTrunkSize();    // 500
        santafe.printTrunkSize(200); // 700
        santafe.go();                // santafe 이(가) 공기의 저항을 강하게 받으며 움직입니다.
    }
}
```
상속에서 사용했던 예제를 그대로 사용해서 CarMain 클래스만 조금 바꿔보았다. printTrunkSize()메서드는 오버로딩하여 인자가 무항이거나 1개인 경우로 
사용 케이스를 분리하였고, go()메서드는 Suv클래스에서 오버라이딩, 즉 재정의하여 출력 텍스트를 조금 바꿔보았다. ***상위클래스 타입의 객체 참조 변수를 사용하더라도
하위 클래스에서 오버라이딩한 메서드가 호출***되어 "santafe 이(가) 공기의 저항을 강하게 받으며 움직입니다." 가 출력될 것이다.


# 캡슐화
캡슐화는 정보은닉과 관계가 깊다. 자바는 접근제어자를 통해 캡슐화를 구현한다. 접근 제어자가 인스턴스 멤버와 쓰일 때와 클래스 멤버와 함께 쓰일 때를 비교해서 살펴볼 필요가 있다.
* [-----이펙티브 자바로 정리-----]


# 참조변수의 복사
Call By Value와 Call By Reference를 다르다고 이해하기 보다는 기본 자료형 변수는 저장하고 값을 그 값 자체로 판단하고, 
참조 변수는 저장하고 있는 값을 주소로 판단한다고 이해하는것이 더 쉽다.
> - 기본 자료형 변수는 값을 값 자체로 판단한다.
> - 참조 자료형 변수는 값을 주소, 즉 포인터로 판단한다.
> - 기본 자료형 변수를 복사할 때, 참조 자료형 변수를 복사할 때 일어나는 일은 같다.
즉 가지고 있는 값을 그대로 복사해서 넘겨준다.

위와 같은 변수의 값을 복사하는 기준은 메서드 내부에서의 동작, 메서드의 인자나 반환값으로 사용되는 경우에 모두 동일하게 작용한다.

